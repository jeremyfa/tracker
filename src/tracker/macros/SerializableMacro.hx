package tracker.macros;

import haxe.macro.Context;
import haxe.macro.Expr;

using StringTools;

class SerializableMacro {

    macro static public function build():Array<Field> {

        #if tracker_debug_macro
        trace(Context.getLocalClass() + ' -> BEGIN SerializableMacro.build()');
        #end

        var fields = Context.getBuildFields();
        var pos = Context.currentPos();
        var localClass = Context.getLocalClass().get();

        // Get next event index for this class path
        var classPath = localClass.pack != null && localClass.pack.length > 0 ? localClass.pack.join('.') + '.' + localClass.name : localClass.name;
        var nextEventIndex = EventsMacro._nextEventIndexes.exists(classPath) ? EventsMacro._nextEventIndexes.get(classPath) : 1;

        // Check if events should be dispatched dynamically by default on this class
        #if (!completion && !display)
        var dynamicDispatch = #if tracker_dynamic_dispatch true #else EventsMacro.hasDynamicEventsMeta(localClass.meta.get()) #end;
        #else
        var dynamicDispatch = false;
        #end

        // Check class fields
        var fieldsByName = new Map<String,Bool>();
        for (field in fields) {
            fieldsByName.set(field.name, true);
        }

        // Get entity type
        #if tracker_ceramic
        var entityTypeStr = 'ceramic.Entity';
        #else
        var entityTypeStr = TrackerMacro.entityTypeStr;
        if (entityTypeStr == null)
            entityTypeStr = 'tracker.Entity';
        #end

        // Also check parent fields
        var inheritsFromEntity = (classPath == entityTypeStr);
        var parentHold = localClass.superClass;
        var parent = parentHold != null ? parentHold.t : null;
        var numParents = 0;
        while (parent != null) {

            if (!inheritsFromEntity && parentHold.t.toString() == entityTypeStr) {
                inheritsFromEntity = true;
            }

            for (field in parent.get().fields.get()) {
                fieldsByName.set(field.name, true);
            }

            parentHold = parent.get().superClass;
            parent = parentHold != null ? parentHold.t : null;
            numParents++;
        }

        // In case of dynamic dispatch, check if event dispatcher
        // field was added already on current class fields
        var dispatcherName:String = null;
        if (dynamicDispatch) {
            dispatcherName = '__events' + numParents;
            if (!fieldsByName.exists(dispatcherName)) {
                EventsMacro.createEventDispatcherField(pos, fields, dispatcherName);
            }
        }

#if (completion || (!display && !completion))
        // Gather default values
        var defaultValueFields = [];
        var prefixLen = 'unobserved'.length;
        var used = new Map<String,Bool>();
        var enumTypes = null;
        for (field in fields) {

            if (field.access != null && field.access.indexOf(AStatic) != -1)
                continue;

            switch (field.kind) {

                case FVar(t, e), FProp(_, _, t, e):

                    // Remove any prefix generated by other tracker macros
                    var fieldName = field.name;
                    if (fieldName.startsWith('unobserved')) {
                        fieldName = fieldName.charAt(prefixLen).toLowerCase() + fieldName.substr(prefixLen + 1);
                    }

                    if (e != null && !used.exists(fieldName)) {
                        used.set(fieldName, true);

                        defaultValueFields.push({
                            pos: field.pos,
                            name: '_default_' + fieldName,
                            kind: FFun({
                                args: [],
                                ret: t,
                                expr: {
                                    expr: EReturn(e),
                                    pos: field.pos
                                }
                            }),
                            access: [APrivate],
                            doc: '',
                            meta: [{
                                name: ':noCompletion',
                                params: [],
                                pos: pos
                            }]
                        });
                    }

                    // Gather enum type info if relevant
                    var enumType = t != null ? resolveEnumTypeIfRelevant(t) : null;
                    if (enumType != null) {
                        if (enumTypes == null)
                            enumTypes = [];
                        enumTypes.push(enumType);
                    }

                default:
            }
        }
        fields = fields.concat(defaultValueFields);

        if (enumTypes != null && enumTypes.length > 0) {
            var enumInfoField = null;
            var shouldAddEnumInfoField = true;

            for (field in fields) {
                if (field.name == '_serializeEnumInfo') {
                    enumInfoField = field;
                    break;
                }
            }
            if (enumInfoField == null) {
                enumInfoField = {
                    pos: pos,
                    name: '_serializeEnumInfo',
                    kind: FVar((macro :Map<String,Map<String,Array<String>>>), (macro [])),
                    access: [AStatic, APublic],
                    doc: '',
                    meta: [{
                        name: ':noCompletion',
                        params: [],
                        pos: pos
                    }]
                }
            }

            // Gather existing info in order not to duplicate it
            var existingEnumNames = new Map<String,Bool>();
            switch enumInfoField.kind {
                default:
                case FVar(t, e):
                    switch e.expr {
                        default:
                        case EArrayDecl(values):
                            for (value in values) {
                                switch value.expr {
                                    default:
                                    case EBinop(op, e1, e2):
                                        switch e1.expr {
                                            default:
                                            case EConst(CIdent(s)):
                                                existingEnumNames.set(s, true);
                                        }
                                }
                            }
                    }
            }

            // Add enum info
            var didAddAnyEnumInfo = false;
            switch enumInfoField.kind {
                default:
                case FVar(t, e):
                    switch e.expr {
                        default:
                        case EArrayDecl(values):
                            var newValues = [].concat(values);
                            for (enumType in enumTypes) {
                                switch enumType {
                                    default:
                                    case TEnum(t, params):
                                        var type = t.get();
                                        var typePath = type.name;
                                        if (type.pack != null && type.pack.length > 0) {
                                            typePath = type.pack.join('.') + '.' + typePath;
                                        }
                                        if (!existingEnumNames.exists(typePath)) {
                                            existingEnumNames.set(typePath, true);
                                            var enumLists:Map<String,Array<String>> = new Map();
                                            var hasLists = false;
                                            for (construct in t.get().constructs) {
                                                switch construct.type {
                                                    default:
                                                    case TFun(args, ret):
                                                        hasLists = true;
                                                        var list = [];
                                                        for (arg in args) {
                                                            list.push(arg.name);
                                                        }
                                                        enumLists.set(construct.name, list);
                                                }
                                            }
                                            if (hasLists) {
                                                didAddAnyEnumInfo = true;
                                                var arrayExprContent = [];
                                                for (key => val in enumLists) {
                                                    var valArrayExpr = [];
                                                    for (item in val) {
                                                        valArrayExpr.push({
                                                            expr: EConst(CString(item)),
                                                            pos: pos
                                                        });
                                                    }
                                                    arrayExprContent.push({
                                                        expr: EBinop(
                                                            OpArrow,
                                                            {
                                                                expr: EConst(CString(key)),
                                                                pos: pos
                                                            },
                                                            {
                                                                expr: EArrayDecl(valArrayExpr),
                                                                pos: pos
                                                            }
                                                        ),
                                                        pos: pos
                                                    });
                                                }
                                                newValues.push({
                                                    expr: EBinop(
                                                        OpArrow,
                                                        {
                                                            expr: EConst(CString(typePath)),
                                                            pos: pos
                                                        },
                                                        {
                                                            expr: EArrayDecl(arrayExprContent),
                                                            pos: pos
                                                        }
                                                    ),
                                                    pos: pos
                                                });
                                            }
                                        }
                                }
                            }
                            e.expr = EArrayDecl(newValues);
                    }
            }

            if (shouldAddEnumInfoField && didAddAnyEnumInfo) {
                fields.push(enumInfoField);
            }
        }
#end

        if (!fieldsByName.exists('_serializeId')) {
            fields.push({
                pos: pos,
                name: '_serializeId',
                kind: FVar((macro :String), (macro tracker.Utils.uniqueId())),
                access: [APublic],
                doc: '',
                meta: [{
                    name: ':noCompletion',
                    params: [],
                    pos: pos
                }]
            });
        }

        // Add serialize/deserialize events
        if (!fieldsByName.exists('emitSerialize')) {
            var eventField = {
                pos: pos,
                name: 'serialize',
                kind: FFun({
                    args: [],
                    ret: macro :Void,
                    expr: null
                }),
                access: [],
                doc: 'Event when this object gets serialized.',
                meta: []
            };
            nextEventIndex = EventsMacro.createEventFields(eventField, fields, fields, fieldsByName, dynamicDispatch, nextEventIndex, dispatcherName, inheritsFromEntity);

            eventField = {
                pos: pos,
                name: 'deserialize',
                kind: FFun({
                    args: [],
                    ret: macro :Void,
                    expr: null
                }),
                access: [],
                doc: 'Event when this object gets deserialized.',
                meta: []
            };
            nextEventIndex = EventsMacro.createEventFields(eventField, fields, fields, fieldsByName, dynamicDispatch, nextEventIndex, dispatcherName, inheritsFromEntity);
        }

        // Store next event index for this class path
        EventsMacro._nextEventIndexes.set(classPath, nextEventIndex);

        #if tracker_debug_macro
        trace(Context.getLocalClass() + ' -> END SerializableMacro.build()');
        #end

        return fields;

    }

    static function hasSerializeMeta(field:Field):Bool {

        if (field.meta == null || field.meta.length == 0) return false;

        for (meta in field.meta) {
            if (meta.name == 'serialize') {
                return true;
            }
        }

        return false;

    }

    static function unwrapType(type:haxe.macro.Type, unwrapFromArrayAndMap:Bool = true) {

        switch type {
            case TMono(t): t;
            case TEnum(t, params):
            case TInst(t, params):
                if (unwrapFromArrayAndMap) {
                    var type = t.get();
                    if (params != null && params.length == 1) {
                        if (type.name == 'Array' || type.name == 'ReadOnlyArray' || type.name == 'StringMap' || type.name == 'IntMap') {
                            return unwrapType(params[0]);
                        }
                    }
                    if (params != null && params.length == 2) {
                        if (type.name == 'ReadOnlyMap' || type.name == 'Map') {
                            return unwrapType(params[1]);
                        }
                    }
                }
            case TType(t, params):
                var type = t.get();
                if (unwrapFromArrayAndMap) {
                    if (params != null && params.length == 1) {
                        if (type.name == 'Array' || type.name == 'ReadOnlyArray' || type.name == 'StringMap' || type.name == 'IntMap') {
                            return unwrapType(params[0]);
                        }
                    }
                    if (params != null && params.length == 2) {
                        if (type.name == 'ReadOnlyMap' || type.name == 'Map') {
                            return unwrapType(params[1]);
                        }
                    }
                }
                return unwrapType(t.get().type);
            case TFun(args, ret):
            case TAnonymous(a):
            case TDynamic(t):
            case TLazy(f):
                return unwrapType(f());
            case TAbstract(t, params):
                var toStr = '' + t;
                var underlyingType = t.get().type;
                if (params != null && params.length > 0) {
                    if (toStr == 'Null') {
                        return unwrapType(params[0]);
                    }
                }
                if (unwrapFromArrayAndMap) {
                    var type = t.get();
                    if (params != null && params.length == 1) {
                        if (type.name == 'Array' || type.name == 'ReadOnlyArray' || type.name == 'StringMap' || type.name == 'IntMap') {
                            return unwrapType(params[0]);
                        }
                    }
                    if (params != null && params.length == 2) {
                        if (type.name == 'ReadOnlyMap' || type.name == 'Map') {
                            return unwrapType(params[1]);
                        }
                    }
                }
                switch underlyingType {
                    case TAbstract(t, params):
                        var toStrUnder = '' + t;
                        if (toStr == toStrUnder) {
                            return type;
                        }
                    default:
                        return unwrapType(underlyingType);
                }
        }

        return type;

    }

    static function resolveEnumTypeIfRelevant(t:ComplexType) {

        var type = Context.resolveType(t, Context.currentPos());
        if (type != null) {
            type = unwrapType(type);
            if (type != null) {
                switch type {
                    default:
                    case TEnum(t, params):
                        return type;
                }
            }
        }

        return null;

    }

}
